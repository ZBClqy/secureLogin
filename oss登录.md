# 安全策略下的oss登录

这是一个安全策略下的单点登录,这里只做思想的引导

首先我们需要用mvc模式写一个登录，为什么要使用mvc那是因为前后端分离的登录我们需要去交互，这样我们就可以通过google的抓包就可以看到我们的交互，而使用我们的mvc只能看到我们提交后面我们不用返回任何东西只需要返回一个页面即可，在这个登录中，我们首先请求但是我使用的是ajax返回空的形式，然后在后面去种植cookie，最后使用一个跳转页面去跳转到同子域名的客户端，因为相同父级域名的子域名的cookie可以相互通信

随后就是开发我们的客户端，我们的客户端只需要在我们的路由中去拦截我们的路由，在路由中去判断是否登录

这里需要先说明一下我们后面的通信的cookie和localStorage的数据格式

localStroage

首先是我们的localStroage

我们需要status 这个参数用来判断系统是否保持登录

然后就是我们的date 这个参数用来判断是否长期未操作，我们只需要判断当前的时间和date的差值是否小于0即可，date是我们设置的时间差

然后就是我们的expire这个时间是我们系统的过期时间，因为date时间我们会去判断不断地刷新，所以我们需要一个系统时间的阈值，如果超过系统时间我们就会去系统打卡，如果打卡失败就会退出登录

接下来就是我们的客户端操作了

我们通过判断我们的cookie是否有我们的openId如果没有就是未登录

这时候我们创建一个iframe然后去链接我们的登录系统这时候我们没有携带回跳的路径，而之前的登录的时候会携带我们客户端的路径好去跳转，在没有后缀路径的时候，然后判断我们的status是否一直保持登录，如果不是服务端就会将传递cookie的时候去删除我们的cookie

然后需要去每个接口请求中去判断我们的操作时间是否超时，或者我们的系统时间是否过期

先判断我们的系统的时间

这里需要一个闭包，后期我们的接口可能有多个同时，这时候触发去刷新我们的刷新这样会触发多次所以用我们的闭包限制住只能请求一次

然后再判断我们的操作时间，首先判断有操作的话就隔阂两分钟就刷新我们的date，如果一直没操作直到当前的时间大于date的时间这时候我们直接删除所所有的cookie，然后发送消息删除服务端的cookie

最后在我们没有保持登录时

我们监听窗口的关闭状态时，然后判断status确定是不保存登录时，就直接删除cookie，这样窗口重新加载或者重新打开时因为没有cookie而且服务端也不会去保存cookie直接就重新登录了

还有我们退出登录的时候不论status什么状态直接给服务端发送消息删除cookie然后删除自身的cookie跳转回登录页面

这就是我们登录系统的大致模型